#### 1.tuple不可变，但是tuple的元素如果是list这样的可变对象，那么也是可以通过给list内元素赋值改变tuple的实际内容的。

#### 2.计算机只能处理数字，因此产生了字符编码，把非数字转换成数字.

- 计算机被设置成8个byte表示一个字节，所以一个字节表示的最大数就是255。
- 世界上存在诸多语言，ASCII就是最早适用于美国的字符编码，包括a-zA-Z0-9及其他一些字符。
- unicode把各国标准统一到一起。
- 经常使用utf-8，可变长编码，减少内存占用浪费。

#### 3.if/else语句

- 执行时从上往下判断，如果某个判断是True，把该判断对应的语句执行后，就会忽略剩下的elif和else。
- if x:  print('')语句的意思是只要`x`是非零数值、非空字符串、非空list等，就判断为`True`，否则为`False`。

#### 4.循环

- break，提前退出循环，循环结束。
- continue，continue以后的代码不会执行，跳过当前的这次循环，直接开始下一次循环，继续循环。
- return，函数体内部的语句在执行时，一旦执行到`return`时，函数就执行完毕，并将结果返回。

#### 5.dic和set

- dic的存取速度快，list存取速度慢，len越大，两者的存取速度差异越明显。
- set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
- set是无序的和无重复的，会自动过滤重复值，在进行一些不重复上可以使用。

```python
s = set([1,2,3])  #set的创建需要一个list。
s.add(4)  #可以使用add函数添加值，添加的值如果和set里的key是一样的，会自动过滤。
s.remove(4) #移除key
```

- 对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。

```python
a = 'abc'
b = a.replace('a','A')
print(a,b)
>>>'abc' 'Abc'  #a变量自身没有改变，在使用函数时返回了新的对象。
```

#### 6.数据类型检查可以用内置函数`isinstance()`

```python
if isinstance(x,(int,float)):  #变量x，为整数或者浮点
    raise TypeError()
    
from collections import Iterable
isinstance('abc', Iterable) #判断‘abc’是否是可迭代对象
```

#### 7.定义默认参数要牢记一点：默认参数必须指向不变对象！

```python
def add_end(L=[]):   #本函数的默认参数是可变对象
    L.append('END')
    return L
#因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。
def add_end(L=None): #本函数默认参数为不可变对象
    if L is None:
        L = []
    L.append('END')
    return L
```

#### 8.参数说明

- 可变参数：可变参数允许你**传入0个或任意个参数**，这些可变参数在函数调用时**自动组装为一个tuple**。定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号

```python
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
```

- 而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。关键字参数有什么用？它可以扩展函数的功能。比如，在`person`函数里，我们保证能接收到`name`和`age`这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。

```python
def person(name, age, **kw):  # **表示接受任意个含参数名的参数
    print('name:', name, 'age:', age, 'other:', kw)

def person(name, age, *, city, job):   
    #  *表示只接受任意个key是city和job的参数，没有*，后边的city和job将被识别成位置参数
    print(name, age, city, job)
    
def f1(a, b, c=0, *args, **kw):  #可以混合调用
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)
    
```

#### 9.递归函数

- 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
- 使用递归函数需要注意防止栈溢出。

```python
def fact(n):   #阶乘
    if n==1:
        return 1
    return n * fact(n - 1)
```

#### 10.迭代器

- python内置的`enumerate`函数可以把一个list变成索引-元素对，这样就可以在`for`循环中同时迭代索引和元素本身。
- dict迭代时可以有多种方式。

```python
#同时迭代list的下标和值
for i,value in enumrate(['a','b','c']):
    print(i,value)
#dict的迭代
c = {'a':0,'b':9}
for i in c.values() :
    print(i)
    
for i,j in d.items():
    print(i,j)
    
```

#### 11.列表生成式

- 简洁的生成list

```python
#使用list()函数，生成简单列表
list(range(1,100))
#生成复杂list 包括三部分[变量，变量迭代，条件],注意条件中只能有if语句不能有else，加上else就是确定了，而不是条件
#单层循环
[x for x in range(1,100) if x%2 == 0]
#双层循环
[m+n for m in 'abc' for n in 'xyz']
>>> ['ax', 'ay', 'az', 'bx', 'by', 'bz', 'cx', 'cy', 'cz']

```

#### 12.生成器（generator）

- 在Python中，这种一边循环一边计算的机制，称为生成器：generator。
- 相对list，在数据量庞大时，可以大大减少数据量，减少内存使用。
- generator保存的是算法，每次调用`next(g)`，就计算出`g`的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出`StopIteration`的错误。

~~~python
li = [x for x in range(1,100) if x%2 == 1]
#生成器与列表生成式的唯一区别是genetator使用()
gene = (x for x in range(1,100) if x%2 == 0) 
#gene可迭代，一般由for循环打开
for i in range(10):
    print(next(gene))
for i in gene:
    print(i)
#斐波那契数列生成的函数
def fib(max):
    n,a,b = 0,0,1
    while max > n:
        print(b)
        a,b = b,a+b
        n = n + 1
    return 'Done'
#将fib函数转换成generator
def fib(max):
    n,a,b = 0,0,1
    while max > n:
        #将print换成了yield函数
        yield b
        a,b = b,a+b
        n = n + 1
    return 'Done'
a = fib(5) 
print(a)
>>> <generator object fib at 0x0000022602E202C8>


#杨辉三角
'''
第一行  [1,2,1]
第二行计算方式  0,1,2,1
              +1,2,1,0
              =1,3,3,1
              可以看出是在给第一行的list前后补零相加而成的
'''
#用函数实现
def triangeles(n):
    b = [1]
    while len(b) < n:
        print(b)
        #此处为什么不直接写成c = B.insert(0,0),原因在于insert函数直接修改原列表，并没有返回值，所以c会返回None.
        c = [0]+b
        d = b+[0]
        b = [c[i]+d[i] for i in range(len(c))]  
triangeles(10)
#用生成器实现
def triangels():
    b = [1]
    while True:
        yield b
        c = [0] + b
        d = b + [0]
        b = [c[i]+d[i] for i in range(len(c))]
n = 1
for i in triangels():
    n = n + 1
    print(i)
    if n > 10:
        break
~~~

#### 13.迭代器

- 可以被`next()`函数调用并不断返回下一个值的对象称为迭代器：`Iterator`。
- 生成器都是`Iterator`对象，但`list`、`dict`、`str`虽然是`Iterable`，却不是`Iterator`。

~~~python
from collections import Iterable
#使用isinstance(obj,类型)判断数据类型
isinstance('abc', Iterable) #判断‘abc’是否是可迭代对象
~~~

#### 14.函数式编程

- 高阶函数
  - `abs(-10)`是函数调用，而`abs`是函数本身
  - 函数本身也可以赋值给变量，即：变量可以指向函数
  - 函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数
  - map/reduce函数
    - `map()`函数接收两个参数，一个是函数，一个是`Iterable`，`map`将传入的函数依次作用到序列的每个元素，并把结果作为新的`Iterator`返回。
    - reduce函数先要import，直接计算出结果
    - reduce和map可以套用，简化程序
  - filter函数
    - `filter()`也接收一个函数和一个序列。和`map()`不同的是，`filter()`把传入的函数依次作用于每个元素，然后根据返回值是`True`还是`False`决定保留还是丢弃该元素。
  - sorted函数
    - Python内置的`sorted()`函数就可以对list进行排序
    - `sorted()`函数也是一个高阶函数，它还可以接收一个`key`函数来实现自定义的排序

~~~python
>>> f = abs
>>> f
<built-in function abs>
#高阶函数，fun作为函数传入
def highorderFunction(fun,a,b):
    return fun(a),fun(b)
c = highorderFunction(abs,-10,2)
print(c)

#map函数,返回map对象，可迭代
def fun(x):
	return x*x
li = [x for x in range(10)]
#map对象列表化
new_li = list(map(fun,li))


#reduce函数，返回value
from functools import reduce
def addnum(x,y):
    return x*10+y
li = [x for x in range(1,20,2)]
r = reduce(addnum,li)
print(r)

#reduce和map函数混合调用，实现字符串转整数
from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return DIGITS[s]
    return reduce(fn, map(char2num, s))
#使用lambda函数继续简化
from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def char2num(s):
    return DIGITS[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))

#首字母大写
def usersipt(n):
    users = []
    for i in range(n):
        ipt = input('Please Input Some Words:')
        users.append(ipt)
    return users
def firstNum(str):
    return str[0].upper()+str1:]
li = list(map(firstNum,usersipt(5)))
print(li)
~~~

~~~python
#高阶函数之filter函数
# 生成所有的质数，使用生成器

def _odd_iter():    #基数生成器
    n=1
    while True:
        n = n + 2
        yield n

def _not_divisiable(n):    #筛选函数
    return lambda x : x % n > 0    #此处表示余数大于0，即反向筛选出余数是0的，即可以整除的奇数

def primes():
    yield 2
    it = _odd_iter()  #初始化序列
    while True:
        n = next(it)
        yield n
        it = filter(_not_divisiable(n),it)  #筛选序列
'''
m = 1
for i in primes():  #笨重
    print(i)
    m = m + 1
    if m > 50:
        break
'''
for i in primes():   #简洁
    if i < 1000:
        print(i)
    else:
        break

~~~

~~~python
#字符串切片
#sorted会排列，不适合逆序

#reversed函数实现逆序排列
a= 'linchyeats'
b = reversed(a)
c = [i for i in b]
print(''.join(c))

str = 'gjingbabylinchyeats'
print(str[1:5])
print(str[:5])
print(str[1:])
print(str[::5])  #从头开始每隔5个字符取一个
print(str[1::5])  #从第二位开始每隔5个字符取一个
print(str[::-1])  #从0开始每隔-1取一个，就是逆序
print(str[-1::-1])  #同上
~~~

~~~python
#筛选回数

def natureNum():    #自然数生成器
    n = 1
    while True:
        yield n
        n = n + 1

def _intTostr(m):   #筛选逆序后与原来相同的数字
    if str(m) == str(m)[::-1]:
        return m

def huishu():    #使用filter筛选，此处直接使用函数名_intTostr，因只有一个参数，即由后边生成器提供
    return filter(_intTostr,natureNum())   #若有多个参数，正常就会继续引入参数_intTostr(n)，n需要定义
#返回的filter为迭代器
for i in huishu():
    if i < 1000:
        print(i)
    else:
        break

~~~

~~~python
#sorted函数，高阶参数体现在参数上，key，reverse
li = [-33,-4,23,90,-6]          #数字列表
lis = sorted(li)                #无参数按大小排序
li_sort = sorted(li,key=abs)    #按绝对值大小排序
strli = ['Gjingbaby','yeats','Linch','baby']
s1 = sorted(strli)              #按ascii字母顺序
s2 = sorted(strli,key=str.lower)  #按首字母小写排列
s3 = sorted(strli,key=str.lower,reverse=True)   #按首字母小写排列后，再逆序
print(s2,'\n',s3)


~~~





