## 模块

1.当我们在命令行运行`hello`模块文件时，Python解释器把一个特殊变量`__name__`置为`__main__`，而如果在其他地方导入该`hello`模块时，`if`判断将失败，因此，这种`if`测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。

- 以下为hello.py文件

~~~python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '   #第一个字符串都是注释

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
~~~

2.在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过`_`前缀来实现的。

~~~python
__xxx__     特殊变量：__doc__,__name__
_abc		严格来说不是私有变量，只是向外部表明我是私有变量，但是还是可以访问的
__xxx       私有变量或函数名
~~~

我们在模块里公开`greeting()`函数，而把内部逻辑用private函数隐藏起来了，这样，调用`greeting()`函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即：

外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。

~~~python
def _private_1(name):
    return 'Hello, %s' % name

def _private_2(name):
    return 'Hi, %s' % name

def greeting(name):
    if len(name) > 3:
        return _private_1(name)
    else:
        return _private_2(name)
~~~

3.导入模块时，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在`sys`模块的`path`变量中：

~~~python
>>> import sys
>>> sys.path

>>> ['', 'C:\\Python37\\python37.zip', 'C:\\Python37\\DLLs', 'C:\\Python37\\lib', 'C:\\Python37', 'C:\\Python37\\lib\\site-packages', 'C:\\Python37\\lib\\site-packages\\win32', 'C:\\Python37\\lib\\site-packages\\win32\\lib', 'C:\\Python37\\lib\\site-packages\\Pythonwin']

#可以添加自己的搜索目录,方便搜索，在运行时修改，结束后失效
#设置环境变量是长久的
>>> sys.path.append(r'E:\pyworkspace\ScrapyLearn')
>>> sys.path
['', 'C:\\Python37\\python37.zip', 'C:\\Python37\\DLLs', 'C:\\Python37\\lib', 'C:\\Python37', 'C:\\Python37\\lib\\site-packages', 'C:\\Python37\\lib\\site-packages\\win32', 'C:\\Python37\\lib\\site-packages\\win32\\lib', 'C:\\Python37\\lib\\site-packages\\Pythonwin', 'E:\\pyworkspace\\ScrapyLearn']
~~~





