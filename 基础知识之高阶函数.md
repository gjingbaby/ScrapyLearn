#### 1.返回函数

~~~python
def lazy_sum(*args):
    def _sum():
        a = 0
        for i in args:
            a = a + i
        return a
    return _sum
b = lazy_sum(3,4,5,6)
print(b) #返回的结果是函数func，如果要得到数值，需要调用返回的函数，即b()
>>> <function lazy_sum.<locals>._sum at 0x000002601FC664C8>
~~~

- 当`lazy_sum`返回函数`sum`时，相关参数和变量都保存在返回的函数中，这种称为“**闭包（Closure）**”的程序结构拥有极大的威力。
- 当我们调用`lazy_sum()`时，每次调用都会返回一个新的函数，即使传入相同的参数,两个函数还是不一样。
- 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。

~~~python
def count():
    fs = []
    for i in range(1,4):
        def f():
            return i*i
        fs.append(f)
    return fs

f1,f2,f3 = count()   #f1,f2,f3组成列表
print(f1(),f2(),f3())  #此处结果为9，9，9；因为fs存储的是函数，当第三次返回时i = 3，所以最后调用时都以3为准

~~~

~~~python
def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1,4):
        fs.append(f(i))   #此处直接将i赋值给f函数，固定了其参数，同时也得益于代码结构的分开
    return fs

f1,f2,f3 = count()   #此处的赋值结果是f1,f2,f3是三个未被调用的函数
print(f1(),f2(),f3())  #结果为1，4，9
~~~

#### 2.匿名函数

- 关键字`lambda`表示匿名函数，冒号前面的`x`表示函数参数。
- lambda函数逻辑简单，但作用范围有限
- lambda经常作为其他函数返回值

~~~python
f = lambda x:x*x实际上就是
def f(x):
    return x*x	
f(5)
>>> 25

a = list(map(lambda x:x*x,[x for x in range(1,10)]))
print(a)

b = list(filter(lambda n : n % 2 == 1,range(1,20)))
print(b)
f = lambda n : n % 2 == 1   #此处lambda函数相当于下边的条件返回
def f(n):
    if n%2 == 1:
        return n


~~~

#### 3.装饰器

- 我们要增强`now()`函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改`now()`函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。
- 装饰器可以复用。

~~~python
import functools
def log(func):
    @functools.wraps(func)    #把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。
    def wrapper(*args,**kwargs):
        print('call %s:'%func.__name__)
        return func(*args,**kwargs)
    return wrapper
#此处没有改变now函数，但是添加了新功能
#实际上把now函数传入log中，再返回出来，但是在传入log中后，通过wrapper函数在now函数外部添加了新功能
#返回的wrapper函数包含了now函数和新功能
#实际上像剥洋葱一样，一层层往回返
@log
def now():
    print('hello')
~~~

- 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。

  ~~~python
  def log(text):
      def decorator(func):
          @functools.wrap(func)  #把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。
          def wrapper(*args,**kwargs):
              print(text,func.__name__)
              return func(*args,**kwargs)
          return wrapper
      return decorator
  
  @log('excute:')
  def now():
      print('hello world')
  #就像洋葱一样，一层一层
  now()
  
  #记录程序开始时间的装饰器
  import time
  def logTime(func):
      @functools.wrap(func)  #把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。
      def wrapper(*args,**kwargs):
          print('开始时间：',time.ctime())
          return func(*args,**kwargs)
      return wrapper
  
  @logTime
  def timeclock():
      print('hello world')
  
  timeclock()
  
  ~~~

