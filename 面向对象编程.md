## 1.面向对象编程

#### 1.类和实例（class and instance）

- 面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

- 在Python中，定义类是通过`class`关键字。
- 注意到`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。
- 有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去。

~~~python
class student():
    def __init__(self,name,score):
        self.name = name
        self.score = score

    def prtscore(self):
        print('The score of %s is %d.'%(self.name,self.score))

    def gtlevel(self):
        if self.score > 90:
            return 'The level of %s is A'%(self.name)
        elif self.score < 60:
            return 'The level of %s is C'%(self.name)
        else:
            return 'The level of %s is B'%(self.name)

stdt1 = student('jack',76)
stdt1.prtscore()
print(stdt1.gtlevel())
~~~

#### 2.访问限制

- 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。
- 但是如果外部代码要获取name和score怎么办？可以给Student类增加`get_name`和`get_score`这样的方法。
- 如果又要允许外部代码修改score怎么办？可以再给Student类增加`set_score`方法。
- 你也许会问，原先那种直接通过`bart.score = 99`也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数。
- **双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量。**

~~~python
class student():
    def __init__(self,name,score):
        self.__name = name
        self.__score = score
    def gtName(self):
        return self.__name
    def gtScore(self):
        return self.__score
    def stScrore(self,newscore):   #检查输入的参数
        if newscore < 100 and newscore > 0:
            self.__score = newscore
        else:
            raise ValueError('Please Input Right Score.')
    def prtscore(self):
        print('The score of %s is %d.'%(self.__name,self.__score))

    def gtlevel(self):
        if self.__score > 90: 
            return 'The level of %s is A'%(self.__name)
        elif self.__score < 60:
            return 'The level of %s is C'%(self.__name)
        else:
            return 'The level of %s is B'%(self.__name)

stdt1 = student('jack',76)
print(stdt1.gtName())		 #通过方法获取name属性
print(stdt1.gtScore())
print(stdt1.gtlevel())
stdt1.stScrore(80)			 #通过方法设置分数
print(stdt1.gtScore())        
print(stdt1._student__name)   #访问私有变量
~~~

#### 3.继承，多态，鸭子类型（inherit,Polymorphism,duck）

- 当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。
- 继承有什么好处？最大的好处是子类获得了父类的全部功能。由于`Animial`实现了`run()`方法，因此，`Dog`和`Cat`作为它的子类，什么事也没干，就自动拥有了`run()`方法：

~~~python
class Animal():
    def run(self):
        print('Animal is running...')
#inherit BaseClass
class Dog(Animal):
    pass
class Cat(Animal):
    pass

dog = Dog()
cat = Cat()
dog.run()
cat.run()

>>> Animal is running...
>>> Animal is running...
~~~

- 当子类和父类都存在相同的`run()`方法时，我们说，子类的`run()`覆盖了父类的`run()`，在代码运行的时候，总是会调用子类的`run()`。这样，我们就获得了继承的另一个好处：多态。

~~~python
class Animal():
    def run(self):
        print('Animal is running...')
#重写了父类的run方法，
class Dog(Animal):
    def run(self):
        print('Dog is running...')
class Cat(Animal):
    def run(self):
        print('Cat is running...')

dog = Dog()
cat = Cat()
dog.run()
cat.run()

>>> Dog is running...
>>> Cat is running...
~~~

- 新增一个`Animal`的子类，不必对`run_twice()`做任何修改，实际上，任何依赖`Animal`作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。
- 对于Python这样的动态语言来说，则不一定需要传入`Animal`类型。我们只需要保证传入的对象有一个`run()`方法就可以了

~~~python
class Animal():
    def run(self):
        print('Animal is running...')

class Dog(Animal):
    def run(self):
        print('Dog is running...')
class Cat(Animal):
    def run(self):
        print('Cat is running...')
class Cob(Animal):
    def run(self):
        print('Cob is running...')


def run_twice(anim):
    anim.run()    #在此处定义run函数时，无报错，实际意义在于只要闯入的参数类有run函数就行
    anim.run()

dog = Dog()
run_twice(dog)

cat = Cat()
run_twice(cat)

cob = Cob()
run_twice(cob)
~~~

#### 4.获取对象信息

- type()函数
- isinstance()函数
- dir()函数，获取对象属性和方法

~~~python
print(isinstance(dog,Dog))
print(isinstance(cat,(Cat,Animal)))
print(dir(dog))
a = 'abc'
print(dir(a))

>>> True
>>> True
>>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'run']
>>> ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', 
'__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 
'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 
'zfill']
~~~

#### 5.实例属性 和类属性

- 实例可以任意绑定属性

~~~python
class student():
    def __init__(self,name):
        self.name = name

s1 = student('jack')
s1.score = 90   #instance可以任意绑定属性,此处绑定了新的属性score
print(dir(s1))

>>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'score']
~~~

- 也可以在类中定义属性，这种属性属于类属性，所有实例都可以访问到

~~~python
class student():
    count = 0
    def __init__(self,name):
        self.name = name

s1 = student('jack')
s1.score = 90   #instance可以任意绑定属性
print(student.count)
print(s1.count)
~~~

~~~python
class student():
    count = 0
    def __init__(self,name):
        self.name = name
        student.count += 1    #类函数内引用类属性时需要加上类名，self指向的时instance
#每个class进行实例化，都会运行一遍__init__函数，所以将累加逻辑写入__init__函数
s1 = student('jack')
s2 = student('mary')
s3 = student('lucy')
print(student.count)

~~~

#### 6.使用splots

- 给实例绑定属性和方法，其他实例不能调用。
- 给类绑定属性和方法，所有实例均可调用。

~~~python
class author():
    pass

#给实例绑定任意属性
a1 = author()
a1.name = 'jack'
print(dir(a1))

#给实例绑定方法
from types import MethodType

def set_score(self,score):
    self.score = score

a4 = author()
a4.set_score = MethodType(set_score,a4)
a4.set_score(90)
print(a4.score)


#给类绑定任意属性
author.name = 'mary'
a2 = author()
print(a2.name)

#给类绑定方法
def gtName(self,name):
    self.name = name
author.gtName = gtName
a3 = author()
a3.gtName('cuidis')
print(a3.name)
~~~

- 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性。
- 使用`__slots__`要注意，`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。

~~~python
class human():
    __slots__ = ('name','age')

h1 = human()
h1.name = 'linch'
print(h1.name)
>>> linch

h1.score = 90
print(h1.score)
>>> 'human' object has no attribute 'score'
~~~

#### 7.@property装饰器

~~~python
#关于property装饰器使用
class student():
    pass
s1 = student()
s1.score = 90

# 此处给实例绑定任意属性,存在问题：
# 1、无法对绑定的属性的值进行检查，数据无效的风险
# 2、那么采用第二种方式，在类里边中定义方法，进行检查

class teacher(object):
    def stScore(self,score):
        if 0 <= score <= 100:
            self.score = score
        else:
            print('Input Right Score!')
            self.score = 'WRONG SCORE'
    def gtScore(self):
        return self.score
t1 = teacher()
t1.stScore(120)
print(t1.gtScore())

# 1、在类中定义方法，对score属性进行检查，实现了控制风险的目的。
# 2、但是稍显麻烦，不简洁
# 3、使用@property装饰器
'''

class commander(object):

    @property
    def score(self):
        return self.score

    @score.setter
    def score(self,score):
        if score > 0 and score < 100:
            self.score = score
c1 = commander()
c1.score = 60
print(c1.score)

#此处可以把函数像属性一样赋值，并检查
#还是暂时不用@property，直接给类加属性
#此处有递归最大变量的问题未解决
~~~

#### 8.多重继承

- 一个类可以同时继承多个父类
- 实际上形同对一个类打上了多个标签

~~~pytho
class Animal(object):
    def miemie(self):
        print('I am an animal.')

class Runable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')

class Dog(Animal,Runable):
    pass
#dog继承了animal和runable的方法
d1 = Dog()
d1.run()
d1.miemie()
>>> Running...
>>> I am an animal.

~~~

- 更进一步的讲，我们可以认为在继承多个类时，是继承了多个类的功能，相当于给当前类在添加功能，更准确的说是‘MixIn’功能。
- 这是一种设计方式，因此倾向于在功能型类定义的时候，类名写成abcMixIn，当前类继承时可以看出功能类。

~~~python
class Dog(AnimalMixIn,RunableMixIn):
    pass
~~~

- 通过给类'MinIn'其他功能，形成更加功能丰富的类，简洁。

#### 9.定制类

- 给类添加响应的特殊变量名函数(**双下划线**)，控制类的属性和方法。
- 比如可迭代属性，可切片属性。

~~~python
class Fib(object):          #给类增加迭代属性，使类可迭代
    def __init__(self,mx):
        self.a,self.b = 0,1
        self.mx = mx
    #可迭代函数和next方法
    def __iter__(self):
        return self
    def __next__(self):
        self.a ,self.b = self.b,self.a + self.b
        if self.a > self.mx:
            raise StopIteration
        return self.a

    # 虽然有了可迭代，但是不能像list一样，读取数据
    def __getitem__(self,n):      #只有在启用这个功能时才传入参数。
        if isinstance(n,int):     #n是整数的时候
            a,b = 1,1
            for i in range(n):
                a,b = b,a+b
            return a
        if isinstance(n,slice):    #n是切片的时候
            start  = n.start
            stop = n.stop
            if start is None:
                start = 0
            a,b = 1,1
            l1 = []
            for i in range(stop):
                if i >= start:
                    l1.append(a)
                a,b = b,a+b
            return l1
f1 = Fib(10)
for i in f1:
    print(i)
print('It is',f1[10])             #只有在启用这个功能时才传入参数。
print('It is',f1[10:15])

>>> 1
>>> 1
>>> 2
>>> 3
>>> 5
>>> 8
>>> It is 89
>>> It is [89, 144, 233, 377, 610]
~~~

- Python还有另一个机制，那就是写一个`__getattr__()`方法，动态返回一个属性。
- 只有在没有找到属性的情况下，才调用`__getattr__`，已有的属性，比如`name`，不会在`__getattr__`中查找。

~~~python
class student(object):
    def __init__(self,name):
        self.name = name
    def __getattr__(self, item):  #获取属性参数形式是instance.attr,如print(s1.name)，会把name作为参数传入
        if item == 'score':
            return 98

s1 = student('mary')
print(s1.name)
print(s1.score)
print(s1.year)
~~~

~~~python
#链式生成地址，使用获取属性__getattr__
class Chain(object):
    def __init__(self,path = ''):
        self.path = path
    def __getattr__(self, item):   #此处动态属性设置成返回类本身，不过是带了path参数，把默认path覆盖
        return Chain('%s/%s'%(self.path,item))
    def __str__(self):
        return self.path

c1 = Chain('hello').store.user.name.line
print(c1)
>>> hello/store/user/name/line

~~~

~~~python
#调用实例本身 使用__call__函数
class student(object):
    def __init__(self,name):
        self.name = name
    def __call__(self):
        return 'My Name Is %s'%self.name

s1 = student('lucy')
print(s1())

~~~

#### 10.元类

- type()函数可以查询变量类型，也可以创建对象。
- python解释器遇到正常class定义时，仅仅是是扫描一下class定义的语法，然后调用type()函数创建class
- metaclass可以编制ORM框架，在python种定义sql表的框架

~~~python
#这在爬虫中存储数据时使用
class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField('id')
    name = StringField('username')
    email = StringField('email')
    password = StringField('password')
~~~

## 2.错误、调试和测试

#### 1.错误处理

- 当我们认为某些代码可能会出错时，就可以用`try`来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即`except`语句块，执行完`except`后，如果有`finally`语句块，则执行`finally`语句块，至此，执行完毕。
- 错误应该有很多种类，如果发生了不同类型的错误，应该由不同的`except`语句块处理。没错，可以有多个`except`来捕获不同类型的错误。
- 此外，如果没有错误发生，可以在`except`语句块后面加一个`else`，当没有错误发生时，会自动执行`else`语句。
- Python的错误其实也是class，所有的错误类型都继承自`BaseException`，所以在使用`except`时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”

~~~python
try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
#第二个except永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也被第一个except给捕获了


~~~

- 调用栈值得就是报错后的一长串

~~~python
Traceback (most recent call last):      #错误的跟踪信息
  File "err.py", line 11, in <module>   #调用main()模块错了，在line 11，原因在line 9
    main()
  File "err.py", line 9, in main        #调用bar('0')出错，但原因是line 6
    bar('0')
  File "err.py", line 6, in bar         #.。。。
    return foo(s) * 2
  File "err.py", line 3, in foo         #return 10 / int(s)语句出错了
    return 10 / int(s)
ZeroDivisionError: division by zero     #错误类型
~~~

- 记录错误

