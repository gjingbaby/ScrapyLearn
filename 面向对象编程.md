# 面向对象编程

#### 1.类和实例（class and instance）

- 面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

- 在Python中，定义类是通过`class`关键字。
- 注意到`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。
- 有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去。

~~~python
class student():
    def __init__(self,name,score):
        self.name = name
        self.score = score

    def prtscore(self):
        print('The score of %s is %d.'%(self.name,self.score))

    def gtlevel(self):
        if self.score > 90:
            return 'The level of %s is A'%(self.name)
        elif self.score < 60:
            return 'The level of %s is C'%(self.name)
        else:
            return 'The level of %s is B'%(self.name)

stdt1 = student('jack',76)
stdt1.prtscore()
print(stdt1.gtlevel())
~~~

#### 2.访问限制

- 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。
- 但是如果外部代码要获取name和score怎么办？可以给Student类增加`get_name`和`get_score`这样的方法。
- 如果又要允许外部代码修改score怎么办？可以再给Student类增加`set_score`方法。
- 你也许会问，原先那种直接通过`bart.score = 99`也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数。
- **双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量。**

~~~python
class student():
    def __init__(self,name,score):
        self.__name = name
        self.__score = score
    def gtName(self):
        return self.__name
    def gtScore(self):
        return self.__score
    def stScrore(self,newscore):   #检查输入的参数
        if newscore < 100 and newscore > 0:
            self.__score = newscore
        else:
            raise ValueError('Please Input Right Score.')
    def prtscore(self):
        print('The score of %s is %d.'%(self.__name,self.__score))

    def gtlevel(self):
        if self.__score > 90: 
            return 'The level of %s is A'%(self.__name)
        elif self.__score < 60:
            return 'The level of %s is C'%(self.__name)
        else:
            return 'The level of %s is B'%(self.__name)

stdt1 = student('jack',76)
print(stdt1.gtName())		 #通过方法获取name属性
print(stdt1.gtScore())
print(stdt1.gtlevel())
stdt1.stScrore(80)			 #通过方法设置分数
print(stdt1.gtScore())        
print(stdt1._student__name)   #访问私有变量
~~~

#### 3.继承，多态，鸭子类型（inherit,Polymorphism,duck）

- 当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。
- 继承有什么好处？最大的好处是子类获得了父类的全部功能。由于`Animial`实现了`run()`方法，因此，`Dog`和`Cat`作为它的子类，什么事也没干，就自动拥有了`run()`方法：

~~~python
class Animal():
    def run(self):
        print('Animal is running...')
#inherit BaseClass
class Dog(Animal):
    pass
class Cat(Animal):
    pass

dog = Dog()
cat = Cat()
dog.run()
cat.run()

>>> Animal is running...
>>> Animal is running...
~~~

- 当子类和父类都存在相同的`run()`方法时，我们说，子类的`run()`覆盖了父类的`run()`，在代码运行的时候，总是会调用子类的`run()`。这样，我们就获得了继承的另一个好处：多态。

~~~python
class Animal():
    def run(self):
        print('Animal is running...')
#重写了父类的run方法，
class Dog(Animal):
    def run(self):
        print('Dog is running...')
class Cat(Animal):
    def run(self):
        print('Cat is running...')

dog = Dog()
cat = Cat()
dog.run()
cat.run()

>>> Dog is running...
>>> Cat is running...
~~~

- 新增一个`Animal`的子类，不必对`run_twice()`做任何修改，实际上，任何依赖`Animal`作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。
- 对于Python这样的动态语言来说，则不一定需要传入`Animal`类型。我们只需要保证传入的对象有一个`run()`方法就可以了

~~~python
class Animal():
    def run(self):
        print('Animal is running...')

class Dog(Animal):
    def run(self):
        print('Dog is running...')
class Cat(Animal):
    def run(self):
        print('Cat is running...')
class Cob(Animal):
    def run(self):
        print('Cob is running...')


def run_twice(anim):
    anim.run()    #在此处定义run函数时，无报错，实际意义在于只要闯入的参数类有run函数就行
    anim.run()

dog = Dog()
run_twice(dog)

cat = Cat()
run_twice(cat)

cob = Cob()
run_twice(cob)
~~~

#### 4.获取对象信息

- type()函数
- isinstance()函数
- dir()函数，获取对象属性和方法

~~~python
print(isinstance(dog,Dog))
print(isinstance(cat,(Cat,Animal)))
print(dir(dog))
a = 'abc'
print(dir(a))

>>> True
>>> True
>>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'run']
>>> ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', 
'__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 
'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 
'zfill']
~~~

#### 5.实例属性 和类属性

- 实例可以任意绑定属性

~~~python
class student():
    def __init__(self,name):
        self.name = name

s1 = student('jack')
s1.score = 90   #instance可以任意绑定属性,此处绑定了新的属性score
print(dir(s1))

>>> ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'name', 'score']
~~~

- 也可以在类中定义属性，这种属性属于类属性，所有实例都可以访问到

~~~python
class student():
    count = 0
    def __init__(self,name):
        self.name = name

s1 = student('jack')
s1.score = 90   #instance可以任意绑定属性
print(student.count)
print(s1.count)
~~~

~~~python
class student():
    count = 0
    def __init__(self,name):
        self.name = name
        student.count += 1    #类函数内引用类属性时需要加上类名，self指向的时instance
#每个class进行实例化，都会运行一遍__init__函数，所以将累加逻辑写入__init__函数
s1 = student('jack')
s2 = student('mary')
s3 = student('lucy')
print(student.count)

~~~

#### 6.使用splots

- 给实例绑定属性和方法，其他实例不能调用。
- 给类绑定属性和方法，所有实例均可调用。

~~~python
class author():
    pass

#给实例绑定任意属性
a1 = author()
a1.name = 'jack'
print(dir(a1))

#给实例绑定方法
from types import MethodType

def set_score(self,score):
    self.score = score

a4 = author()
a4.set_score = MethodType(set_score,a4)
a4.set_score(90)
print(a4.score)


#给类绑定任意属性
author.name = 'mary'
a2 = author()
print(a2.name)

#给类绑定方法
def gtName(self,name):
    self.name = name
author.gtName = gtName
a3 = author()
a3.gtName('cuidis')
print(a3.name)
~~~

- 为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class实例能添加的属性。
- 使用`__slots__`要注意，`__slots__`定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。

~~~python
class human():
    __slots__ = ('name','age')

h1 = human()
h1.name = 'linch'
print(h1.name)
>>> linch

h1.score = 90
print(h1.score)
>>> 'human' object has no attribute 'score'
~~~

#### 7.@property装饰器

~~~python
#关于property装饰器使用
class student():
    pass
s1 = student()
s1.score = 90

# 此处给实例绑定任意属性,存在问题：
# 1、无法对绑定的属性的值进行检查，数据无效的风险
# 2、那么采用第二种方式，在类里边中定义方法，进行检查

class teacher(object):
    def stScore(self,score):
        if 0 <= score <= 100:
            self.score = score
        else:
            print('Input Right Score!')
            self.score = 'WRONG SCORE'
    def gtScore(self):
        return self.score
t1 = teacher()
t1.stScore(120)
print(t1.gtScore())

# 1、在类中定义方法，对score属性进行检查，实现了控制风险的目的。
# 2、但是稍显麻烦，不简洁
# 3、使用@property装饰器
'''

class commander(object):

    @property
    def score(self):
        return self.score

    @score.setter
    def score(self,score):
        if score > 0 and score < 100:
            self.score = score
c1 = commander()
c1.score = 60
print(c1.score)

#此处可以把函数像属性一样赋值，并检查
#还是暂时不用@property，直接给类加属性
#此处有递归最大变量的问题未解决
~~~

