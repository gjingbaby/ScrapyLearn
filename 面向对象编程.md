# 面向对象编程

#### 1.类和实例（class and instance）

- 面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。

- 在Python中，定义类是通过`class`关键字。
- 注意到`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。
- 有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去。

~~~python
class student():
    def __init__(self,name,score):
        self.name = name
        self.score = score

    def prtscore(self):
        print('The score of %s is %d.'%(self.name,self.score))

    def gtlevel(self):
        if self.score > 90:
            return 'The level of %s is A'%(self.name)
        elif self.score < 60:
            return 'The level of %s is C'%(self.name)
        else:
            return 'The level of %s is B'%(self.name)

stdt1 = student('jack',76)
stdt1.prtscore()
print(stdt1.gtlevel())
~~~

#### 2.访问限制

- 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线`__`，在Python中，实例的变量名如果以`__`开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。
- 但是如果外部代码要获取name和score怎么办？可以给Student类增加`get_name`和`get_score`这样的方法。
- 如果又要允许外部代码修改score怎么办？可以再给Student类增加`set_score`方法。
- 你也许会问，原先那种直接通过`bart.score = 99`也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数。
- **双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量。**

~~~python
class student():
    def __init__(self,name,score):
        self.__name = name
        self.__score = score
    def gtName(self):
        return self.__name
    def gtScore(self):
        return self.__score
    def stScrore(self,newscore):   #检查输入的参数
        if newscore < 100 and newscore > 0:
            self.__score = newscore
        else:
            raise ValueError('Please Input Right Score.')
    def prtscore(self):
        print('The score of %s is %d.'%(self.__name,self.__score))

    def gtlevel(self):
        if self.__score > 90: 
            return 'The level of %s is A'%(self.__name)
        elif self.__score < 60:
            return 'The level of %s is C'%(self.__name)
        else:
            return 'The level of %s is B'%(self.__name)

stdt1 = student('jack',76)
print(stdt1.gtName())		 #通过方法获取name属性
print(stdt1.gtScore())
print(stdt1.gtlevel())
stdt1.stScrore(80)			 #通过方法设置分数
print(stdt1.gtScore())        
print(stdt1._student__name)   #访问私有变量
~~~

#### 3.继承，多态，鸭子类型（inherit,Polymorphism,duck）

- 当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。
- 继承有什么好处？最大的好处是子类获得了父类的全部功能。由于`Animial`实现了`run()`方法，因此，`Dog`和`Cat`作为它的子类，什么事也没干，就自动拥有了`run()`方法：

~~~python
class Animal():
    def run(self):
        print('Animal is running...')
#inherit BaseClass
class Dog(Animal):
    pass
class Cat(Animal):
    pass

dog = Dog()
cat = Cat()
dog.run()
cat.run()

>>> Animal is running...
>>> Animal is running...
~~~

- 当子类和父类都存在相同的`run()`方法时，我们说，子类的`run()`覆盖了父类的`run()`，在代码运行的时候，总是会调用子类的`run()`。这样，我们就获得了继承的另一个好处：多态。

~~~python
class Animal():
    def run(self):
        print('Animal is running...')
#重写了父类的run方法，
class Dog(Animal):
    def run(self):
        print('Dog is running...')
class Cat(Animal):
    def run(self):
        print('Cat is running...')

dog = Dog()
cat = Cat()
dog.run()
cat.run()

>>> Dog is running...
>>> Cat is running...
~~~

- 新增一个`Animal`的子类，不必对`run_twice()`做任何修改，实际上，任何依赖`Animal`作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。
- 对于Python这样的动态语言来说，则不一定需要传入`Animal`类型。我们只需要保证传入的对象有一个`run()`方法就可以了

~~~python
class Animal():
    def run(self):
        print('Animal is running...')

class Dog(Animal):
    def run(self):
        print('Dog is running...')
class Cat(Animal):
    def run(self):
        print('Cat is running...')
class Cob(Animal):
    def run(self):
        print('Cob is running...')


def run_twice(anim):
    anim.run()    #在此处定义run函数时，无报错，实际意义在于只要闯入的参数类有run函数就行
    anim.run()

dog = Dog()
run_twice(dog)

cat = Cat()
run_twice(cat)

cob = Cob()
run_twice(cob)
~~~

